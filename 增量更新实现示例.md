# 增量更新实现指南

## 当前状态
当前服务使用基础的`VectorDatabase`，不支持自动增量更新。`IncrementalVectorDatabase`类已完整实现但未启用。

## 启用增量更新的步骤

### 1. 修改Program.cs的依赖注入

将：
```csharp
builder.Services.AddSingleton<VectorDatabase>();
```

改为：
```csharp
builder.Services.AddSingleton<IncrementalVectorDatabase>();
builder.Services.AddSingleton<VectorDatabase>(sp => sp.GetRequiredService<IncrementalVectorDatabase>());
```

### 2. 在McpTools中添加增量更新方法

```csharp
[McpTool("update_csharp_project", "Incrementally update a C# project analysis")]
public async Task<string> UpdateCSharpProjectAsync(string projectPath)
{
    try
    {
        if (_vectorDatabase is not IncrementalVectorDatabase incrementalDb)
        {
            return JsonSerializer.Serialize(new {
                error = "Incremental update not enabled. Please configure IncrementalVectorDatabase."
            });
        }

        _logger.LogInformation("Incrementally updating C# project: {ProjectPath}", projectPath);

        // 重新分析项目
        var projectInfo = await _projectAnalyzer.AnalyzeProjectAsync(projectPath);
        var newSymbols = await _projectAnalyzer.ExtractSymbolsAsync(projectInfo);

        // 执行增量更新
        var summary = await incrementalDb.UpdateProjectAsync(projectInfo.Id, newSymbols, _embeddingService);

        var result = new
        {
            projectId = summary.ProjectId,
            success = summary.Success,
            duration = summary.Duration.TotalMilliseconds,
            addedSymbols = summary.AddedSymbols,
            updatedSymbols = summary.UpdatedSymbols,
            removedSymbols = summary.RemovedSymbols,
            totalSymbols = incrementalDb.Count,
            errorMessage = summary.ErrorMessage
        };

        return JsonSerializer.Serialize(result);
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Error incrementally updating C# project");
        return JsonSerializer.Serialize(new { error = ex.Message });
    }
}
```

### 3. 添加自动触发机制

#### 方法1: 文件系统监控
```csharp
// 在Program.cs中添加文件监控
var fileWatcher = new FileSystemWatcher(projectDirectory)
{
    Filter = "*.cs",
    IncludeSubdirectories = true,
    EnableRaisingEvents = true
};

fileWatcher.Changed += async (sender, e) =>
{
    // 防抖动 - 延迟处理
    await Task.Delay(1000);
    await TriggerIncrementalUpdate(e.FullPath);
};
```

#### 方法2: 定时检查
```csharp
// 在Program.cs中添加定时器
var timer = new Timer(async (state) =>
{
    await CheckForProjectUpdates();
}, null, TimeSpan.FromMinutes(5), TimeSpan.FromMinutes(5));
```

## 增量更新的工作原理

### 1. 文件修改检测
```csharp
private DateTime GetFileLastModified(string filePath)
{
    if (File.Exists(filePath))
    {
        return File.GetLastWriteTimeUtc(filePath);
    }
    return DateTime.MinValue;
}
```

### 2. 变化检测逻辑
- **文件修改**: 比较文件的最后修改时间
- **符号变更**: 比较现有符号与新提取的符号
- **删除检测**: 检查已删除的文件和符号

### 3. 更新流程
1. 检查修改的文件
2. 删除不存在文件的符号
3. 更新修改文件的符号
4. 添加新符号
5. 保存到持久化存储

## 使用示例

### 手动触发增量更新
```json
{
  "name": "update_csharp_project",
  "arguments": {
    "projectPath": "D:\\MyProject\\MyProject.csproj"
  }
}
```

### 预期响应
```json
{
  "projectId": "MyProject",
  "success": true,
  "duration": 234.5,
  "addedSymbols": 5,
  "updatedSymbols": 3,
  "removedSymbols": 1,
  "totalSymbols": 45,
  "errorMessage": null
}
```

## 性能优势

### 1. 减少计算量
- 只重新分析修改的文件
- 避免重复生成未修改符号的嵌入向量

### 2. 更快的响应
- 增量更新通常比完整分析快80-90%
- 保持数据库的实时性

### 3. 资源节约
- 减少CPU和内存使用
- 降低嵌入服务的负载

## 注意事项

1. **文件锁定**: 如果文件正在被编辑，可能需要重试
2. **内存管理**: 定期清理过期的向量数据
3. **持久化**: 确保有足够的磁盘空间存储向量数据库
4. **并发控制**: 避免同时进行多个更新操作