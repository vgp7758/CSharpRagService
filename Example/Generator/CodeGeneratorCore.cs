using System;
using System.Collections.Generic;
using System.IO;
using BitRPC.Protocol.Parser;

namespace BitRPC.Protocol.Generator
{
    public enum TargetLanguage
    {
        CSharp,
        Python,
        Cpp
    }

    public class GenerationOptions
    {
        public TargetLanguage Language { get; set; }
        public string OutputDirectory { get; set; }
        public string Namespace { get; set; }
        public bool GenerateSerialization { get; set; } = true;
        public bool GenerateClientServer { get; set; } = true;
        public bool GenerateFactories { get; set; } = true;
    }

    public interface ICodeGenerator
    {
        void Generate(ProtocolDefinition definition, GenerationOptions options);
    }

    public abstract class BaseCodeGenerator : ICodeGenerator
    {
        protected readonly string _templateDirectory;

        protected BaseCodeGenerator(string templateDirectory = null)
        {
            _templateDirectory = templateDirectory ?? "Templates";
        }

        public abstract void Generate(ProtocolDefinition definition, GenerationOptions options);

        protected void EnsureDirectoryExists(string path)
        {
            if (!Directory.Exists(path))
            {
                Directory.CreateDirectory(path);
            }
        }

        protected string GetOutputPath(GenerationOptions options, params string[] subPaths)
        {
            var path = Path.Combine(options.OutputDirectory, Path.Combine(subPaths));
            EnsureDirectoryExists(Path.GetDirectoryName(path));
            return path;
        }

        protected string GetNamespacePath(string ns)
        {
            return ns?.Replace('.', Path.DirectorySeparatorChar) ?? string.Empty;
        }

        protected virtual string GenerateFileHeader(string fileName, GenerationOptions options)
        {
            return $"// Generated by BitRPC Protocol Generator\n" +
                   $"// File: {fileName}\n" +
                   $"// Language: {options.Language}\n" +
                   $"// Date: {DateTime.Now:yyyy-MM-dd HH:mm:ss}\n\n";
        }
    }

    public class CodeGeneratorFactory
    {
        private readonly Dictionary<TargetLanguage, ICodeGenerator> _generators;

        public CodeGeneratorFactory()
        {
            _generators = new Dictionary<TargetLanguage, ICodeGenerator>
            {
                { TargetLanguage.CSharp, new CSharpCodeGenerator() },
                { TargetLanguage.Python, new PythonCodeGenerator() },
                { TargetLanguage.Cpp, new CppCodeGenerator() }
            };
        }

        public ICodeGenerator GetGenerator(TargetLanguage language)
        {
            if (_generators.TryGetValue(language, out var generator))
            {
                return generator;
            }
            throw new NotSupportedException($"Language {language} is not supported");
        }

        public void AddGenerator(TargetLanguage language, ICodeGenerator generator)
        {
            _generators[language] = generator;
        }
    }

    public class ProtocolGenerator
    {
        private readonly PDLParser _parser;
        private readonly CodeGeneratorFactory _generatorFactory;

        public ProtocolGenerator()
        {
            _parser = new PDLParser();
            _generatorFactory = new CodeGeneratorFactory();
        }

        public void GenerateFromFile(string filePath, GenerationOptions options)
        {
            var content = File.ReadAllText(filePath);
            var definition = _parser.Parse(content);
            Generate(definition, options);
        }

        public void Generate(ProtocolDefinition definition, GenerationOptions options)
        {
            var generator = _generatorFactory.GetGenerator(options.Language);
            generator.Generate(definition, options);
        }

        public void GenerateMultiple(string filePath, List<GenerationOptions> optionsList)
        {
            var content = File.ReadAllText(filePath);
            var definition = _parser.Parse(content);

            foreach (var options in optionsList)
            {
                Generate(definition, options);
            }
        }
    }
}