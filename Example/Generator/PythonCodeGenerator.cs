using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using BitRPC.Protocol.Parser;

namespace BitRPC.Protocol.Generator
{
    public class PythonCodeGenerator : BaseCodeGenerator
    {
        public PythonCodeGenerator() : base("Templates/Python")
        {
        }

        protected override string GenerateFileHeader(string fileName, GenerationOptions options)
        {
            return $"# Generated by BitRPC Protocol Generator\n" +
                   $"# File: {fileName}\n" +
                   $"# Language: {options.Language}\n" +
                   $"# Date: {DateTime.Now:yyyy-MM-dd HH:mm:ss}\n\n";
        }

        public override void Generate(ProtocolDefinition definition, GenerationOptions options)
        {
            var baseDir = GetOutputPath(options);

            if (options.GenerateSerialization)
            {
                GenerateDataStructures(definition, options, baseDir);
                GenerateSerializationCode(definition, options, baseDir);
            }

            if (options.GenerateClientServer)
            {
                GenerateClientCode(definition, options, baseDir);
                GenerateServerCode(definition, options, baseDir);
            }

            if (options.GenerateFactories)
            {
                GenerateFactoryCode(definition, options, baseDir);
            }

            GenerateInitFile(definition, options, baseDir);
        }

        private void GenerateDataStructures(ProtocolDefinition definition, GenerationOptions options, string baseDir)
        {
            var dataDir = Path.Combine(baseDir, "data");
            EnsureDirectoryExists(dataDir);

            var filePath = Path.Combine(dataDir, "models.py");
            var content = GenerateModelsModule(definition, options);
            File.WriteAllText(filePath, content);
        }

        private string GenerateModelsModule(ProtocolDefinition definition, GenerationOptions options)
        {
            var sb = new StringBuilder();
            sb.AppendLine(GenerateFileHeader("models.py", options));
            sb.AppendLine("from dataclasses import dataclass, field");
            sb.AppendLine("from typing import List, Optional, Dict, Any");
            sb.AppendLine("from datetime import datetime");
            sb.AppendLine();

            if (!string.IsNullOrEmpty(options.Namespace))
            {
                sb.AppendLine();
            }

            foreach (var message in definition.Messages)
            {
                sb.AppendLine($"@dataclass");
                sb.AppendLine($"class {message.Name}:");
                sb.AppendLine("    \"\"\"");

                var fieldDoc = message.Fields.Select(f => $"    {f.Name}: {GetPythonType(f)}").ToList();
                if (fieldDoc.Any())
                {
                    sb.AppendLine(string.Join("\n", fieldDoc));
                }
                sb.AppendLine("    \"\"\"");
                sb.AppendLine();

                foreach (var field in message.Fields)
                {
                    var defaultValue = GetPythonDefaultValue(field);
                    sb.AppendLine($"    {field.Name}: {GetPythonType(field)} = {defaultValue}");
                }

                sb.AppendLine();
            }

            return sb.ToString();
        }

        private void GenerateSerializationCode(ProtocolDefinition definition, GenerationOptions options, string baseDir)
        {
            var serializationDir = Path.Combine(baseDir, "serialization");
            EnsureDirectoryExists(serializationDir);

            foreach (var message in definition.Messages)
            {
                var filePath = Path.Combine(serializationDir, $"{message.Name.ToLower()}_serializer.py");
                var content = GenerateMessageSerializer(message, options);
                File.WriteAllText(filePath, content);
            }

            GenerateSerializerRegistry(definition, options, serializationDir);
        }

        private string GenerateMessageSerializer(ProtocolMessage message, GenerationOptions options)
        {
            var sb = new StringBuilder();
            sb.AppendLine(GenerateFileHeader($"{message.Name}_serializer.py", options));
            sb.AppendLine("from typing import Any");
            sb.AppendLine("from bitrpc.serialization import TypeHandler, BitMask, StreamWriter, StreamReader");
            sb.AppendLine($"from ..data.models import {message.Name}");
            sb.AppendLine();

            sb.AppendLine($"class {message.Name}Serializer(TypeHandler):");
            sb.AppendLine();
            sb.AppendLine("    @property");
            sb.AppendLine($"    def hash_code(self) -> int:");
            sb.AppendLine($"        return hash('{message.Name}')");
            sb.AppendLine();
            sb.AppendLine($"    def write(self, obj: {message.Name}, writer: StreamWriter) -> None:");
            sb.AppendLine($"        message: {message.Name} = obj");
            sb.AppendLine("        mask = BitMask()");
            sb.AppendLine();

            var fieldGroups = message.Fields.Select((f, i) => new { Field = f, Index = i })
                                           .GroupBy(x => x.Index / 32)
                                           .ToList();

            for (int group = 0; group < fieldGroups.Count; group++)
            {
                var fields = fieldGroups[group].ToList();
                sb.AppendLine($"        # Bit mask group {group}");
                foreach (var fieldInfo in fields)
                {
                    var field = fieldInfo.Field;
                    var bitIndex = fieldInfo.Index % 32;
                    sb.AppendLine($"        mask.set_bit({bitIndex}, not self._is_default_{field.Type.ToString().ToLower()}(message.{field.Name}))");
                }
                sb.AppendLine($"        mask.write(writer)");
                sb.AppendLine();
            }

            sb.AppendLine("        # Write field values");
            foreach (var field in message.Fields)
            {
                var fieldIndex = message.Fields.IndexOf(field);
                var bitIndex = fieldIndex % 32;
                sb.AppendLine($"        if mask.get_bit({bitIndex}):");
                sb.AppendLine($"            {GeneratePythonWriteField(field)}");
            }

            sb.AppendLine();
            sb.AppendLine($"    def read(self, reader: StreamReader) -> {message.Name}:");
            sb.AppendLine($"        message = {message.Name}()");
            sb.AppendLine();

            for (int group = 0; group < fieldGroups.Count; group++)
            {
                var fields = fieldGroups[group].ToList();
                sb.AppendLine($"        # Read bit mask group {group}");
                sb.AppendLine($"        mask{group} = BitMask()");
                sb.AppendLine($"        mask{group}.read(reader)");
                sb.AppendLine();
            }

            foreach (var field in message.Fields)
            {
                var fieldIndex = message.Fields.IndexOf(field);
                var groupIndex = fieldIndex / 32;
                var bitIndex = fieldIndex % 32;
                sb.AppendLine($"        if mask{groupIndex}.get_bit({bitIndex}):");
                sb.AppendLine($"            {GeneratePythonReadField(field)}");
            }

            sb.AppendLine();
            sb.AppendLine("        return message");
            sb.AppendLine();
            // Add default check methods for each field type
            var fieldTypes = message.Fields.Select(f => f.Type).Distinct();
            foreach (var fieldType in fieldTypes)
            {
                sb.AppendLine($"    def _is_default_{fieldType.ToString().ToLower()}(self, value: {GetPythonTypeName(fieldType)}) -> bool:");
                sb.AppendLine($"        return value == {GetPythonDefaultValueForType(fieldType)}");
                sb.AppendLine();
            }

            return sb.ToString();
        }

        private void GenerateSerializerRegistry(ProtocolDefinition definition, GenerationOptions options, string serializationDir)
        {
            var filePath = Path.Combine(serializationDir, "registry.py");
            var sb = new StringBuilder();
            sb.AppendLine(GenerateFileHeader("registry.py", options));
            sb.AppendLine("from bitrpc.serialization import BufferSerializer");
            sb.AppendLine();

            foreach (var message in definition.Messages)
            {
                sb.AppendLine($"from .{message.Name.ToLower()}_serializer import {message.Name}Serializer");
            }

            sb.AppendLine();
            sb.AppendLine("def register_serializers(serializer: BufferSerializer) -> None:");
            sb.AppendLine("    \"\"\"Register all protocol serializers\"\"\"");

            foreach (var message in definition.Messages)
            {
                sb.AppendLine($"    serializer.register_handler({message.Name}, {message.Name}Serializer())");
            }

            File.WriteAllText(filePath, sb.ToString());
        }

        private void GenerateClientCode(ProtocolDefinition definition, GenerationOptions options, string baseDir)
        {
            var clientDir = Path.Combine(baseDir, "client");
            EnsureDirectoryExists(clientDir);

            foreach (var service in definition.Services)
            {
                var filePath = Path.Combine(clientDir, $"{service.Name.ToLower()}_client.py");
                var content = GenerateServiceClient(service, options);
                File.WriteAllText(filePath, content);
            }
        }

        private string GenerateServiceClient(ProtocolService service, GenerationOptions options)
        {
            var sb = new StringBuilder();
            sb.AppendLine(GenerateFileHeader($"{service.Name}_client.py", options));
            sb.AppendLine("from typing import TypeVar, Generic");
            sb.AppendLine("from bitrpc.client import BaseClient");
            sb.AppendLine($"from ..data.models import {string.Join(", ", service.Methods.Select(m => m.RequestType).Concat(service.Methods.Select(m => m.ResponseType)).Distinct())}");
            sb.AppendLine();

            sb.AppendLine($"class {service.Name}Client(BaseClient):");
            sb.AppendLine($"    \"\"\"Client for {service.Name} service\"\"\"");
            sb.AppendLine();
            sb.AppendLine("    def __init__(self, client):");
            sb.AppendLine("        super().__init__(client)");
            sb.AppendLine();

            foreach (var method in service.Methods)
            {
                sb.AppendLine($"    async def {method.Name}_async(self, request: {method.RequestType}) -> {method.ResponseType}:");
                sb.AppendLine($"        \"\"\"Call {method.Name} method\"\"\"");
                sb.AppendLine($"        return await self.call_async(\"{method.Name}\", request)");
                sb.AppendLine();
            }

            return sb.ToString();
        }

        private void GenerateServerCode(ProtocolDefinition definition, GenerationOptions options, string baseDir)
        {
            var serverDir = Path.Combine(baseDir, "server");
            EnsureDirectoryExists(serverDir);

            foreach (var service in definition.Services)
            {
                var filePath = Path.Combine(serverDir, $"i{service.Name.ToLower()}_service.py");
                var content = GenerateServiceInterface(service, options);
                File.WriteAllText(filePath, content);

                var implFilePath = Path.Combine(serverDir, $"{service.Name.ToLower()}_service_base.py");
                var implContent = GenerateServiceBase(service, options);
                File.WriteAllText(implFilePath, implContent);
            }
        }

        private string GenerateServiceInterface(ProtocolService service, GenerationOptions options)
        {
            var sb = new StringBuilder();
            sb.AppendLine(GenerateFileHeader($"i{service.Name}_service.py", options));
            sb.AppendLine("from abc import ABC, abstractmethod");
            sb.AppendLine($"from typing import {string.Join(", ", service.Methods.Select(m => m.RequestType).Concat(service.Methods.Select(m => m.ResponseType)).Distinct())}");
            sb.AppendLine();

            sb.AppendLine($"class I{service.Name}Service(ABC):");
            sb.AppendLine($"    \"\"\"Interface for {service.Name} service\"\"\"");
            sb.AppendLine();

            foreach (var method in service.Methods)
            {
                sb.AppendLine($"    @abstractmethod");
                sb.AppendLine($"    async def {method.Name}_async(self, request: {method.RequestType}) -> {method.ResponseType}:");
                sb.AppendLine($"        \"\"\"{method.Name} method\"\"\"");
                sb.AppendLine("        pass");
                sb.AppendLine();
            }

            return sb.ToString();
        }

        private string GenerateServiceBase(ProtocolService service, GenerationOptions options)
        {
            var sb = new StringBuilder();
            sb.AppendLine(GenerateFileHeader($"{service.Name}_service_base.py", options));
            sb.AppendLine("from bitrpc.server import BaseService");
            sb.AppendLine($"from .i{service.Name.ToLower()}_service import I{service.Name}Service");
            sb.AppendLine();

            sb.AppendLine($"class {service.Name}ServiceBase(BaseService, I{service.Name}Service):");
            sb.AppendLine($"    \"\"\"Base implementation for {service.Name} service\"\"\"");
            sb.AppendLine();
            sb.AppendLine("    def _register_methods(self) -> None:");
            sb.AppendLine("        \"\"\"Register service methods\"\"\"");

            foreach (var method in service.Methods)
            {
                sb.AppendLine($"        self.register_method(\"{method.Name}\", self.{method.Name}_async)");
            }

            sb.AppendLine();

            foreach (var method in service.Methods)
            {
                sb.AppendLine($"    async def {method.Name}_async(self, request: {method.RequestType}) -> {method.ResponseType}:");
                sb.AppendLine($"        \"\"\"{method.Name} method - to be implemented by derived classes\"\"\"");
                sb.AppendLine("        raise NotImplementedError(\"Method not implemented\")");
                sb.AppendLine();
            }

            return sb.ToString();
        }

        private void GenerateFactoryCode(ProtocolDefinition definition, GenerationOptions options, string baseDir)
        {
            var factoryDir = Path.Combine(baseDir, "factory");
            EnsureDirectoryExists(factoryDir);

            var filePath = Path.Combine(factoryDir, "protocol_factory.py");
            var content = GenerateProtocolFactory(definition, options);
            File.WriteAllText(filePath, content);
        }

        private string GenerateProtocolFactory(ProtocolDefinition definition, GenerationOptions options)
        {
            var sb = new StringBuilder();
            sb.AppendLine(GenerateFileHeader("protocol_factory.py", options));
            sb.AppendLine("from bitrpc.serialization import BufferSerializer");
            sb.AppendLine("from .serialization.registry import register_serializers");
            sb.AppendLine();

            sb.AppendLine("class ProtocolFactory:");
            sb.AppendLine("    \"\"\"Factory for initializing protocol components\"\"\"");
            sb.AppendLine();
            sb.AppendLine("    @staticmethod");
            sb.AppendLine("    def initialize() -> None:");
            sb.AppendLine("        \"\"\"Initialize protocol serializers and components\"\"\"");
            sb.AppendLine("        serializer = BufferSerializer.instance()");
            sb.AppendLine("        register_serializers(serializer)");

            return sb.ToString();
        }

        private void GenerateInitFile(ProtocolDefinition definition, GenerationOptions options, string baseDir)
        {
            var filePath = Path.Combine(baseDir, "__init__.py");
            var sb = new StringBuilder();
            sb.AppendLine(GenerateFileHeader("__init__.py", options));
            sb.AppendLine("\"\"\"");
            sb.AppendLine($"{options.Namespace} Protocol Package");
            sb.AppendLine($"Generated by BitRPC Protocol Generator");
            sb.AppendLine("\"\"\"");
            sb.AppendLine();
            sb.AppendLine("from .factory.protocol_factory import ProtocolFactory");
            sb.AppendLine();
            sb.AppendLine("__all__ = ['ProtocolFactory']");

            File.WriteAllText(filePath, sb.ToString());
        }

        private string GetPythonType(ProtocolField field)
        {
            if (field.IsRepeated)
            {
                return $"List[{GetPythonTypeNameForField(field)}]";
            }

            return GetPythonTypeNameForField(field);
        }

        private string GetPythonTypeName(FieldType type)
        {
            return type switch
            {
                FieldType.Int32 => "int",
                FieldType.Int64 => "int",
                FieldType.Float => "float",
                FieldType.Double => "float",
                FieldType.Bool => "bool",
                FieldType.String => "str",
                FieldType.Vector3 => "Vector3",
                FieldType.DateTime => "datetime",
                _ => "Any"
            };
        }

        private string GetPythonTypeNameForField(ProtocolField field)
        {
            if (field.Type == FieldType.Struct && !string.IsNullOrEmpty(field.CustomType))
            {
                return field.CustomType;
            }
            return GetPythonTypeName(field.Type);
        }

        private string GetPythonDefaultValue(ProtocolField field)
        {
            if (field.IsRepeated) return "field(default_factory=list)";

            return GetPythonDefaultValueForType(field.Type);
        }

        private string GetPythonDefaultValueForType(FieldType type)
        {
            return type switch
            {
                FieldType.Int32 => "0",
                FieldType.Int64 => "0",
                FieldType.Float => "0.0",
                FieldType.Double => "0.0",
                FieldType.Bool => "False",
                FieldType.String => "\"\"",
                FieldType.DateTime => "None",
                _ => "None"
            };
        }

        private string GeneratePythonWriteField(ProtocolField field)
        {
            if (field.IsRepeated)
            {
                return $"writer.write_list(message.{field.Name}, lambda x: {GeneratePythonWriteValue(field.Type, "x")})";
            }

            return $"{GeneratePythonWriteValue(field.Type, $"message.{field.Name}")}";
        }

        private string GeneratePythonWriteValue(FieldType type, string value)
        {
            return type switch
            {
                FieldType.Int32 => $"writer.write_int32({value})",
                FieldType.Int64 => $"writer.write_int64({value})",
                FieldType.Float => $"writer.write_float({value})",
                FieldType.Double => $"writer.write_double({value})",
                FieldType.Bool => $"writer.write_bool({value})",
                FieldType.String => $"writer.write_string({value})",
                _ => $"writer.write_object({value})"
            };
        }

        private string GeneratePythonReadField(ProtocolField field)
        {
            if (field.IsRepeated)
            {
                return $"message.{field.Name} = reader.read_list(lambda: {GeneratePythonReadValue(field.Type)})";
            }

            return $"message.{field.Name} = {GeneratePythonReadValue(field.Type)}";
        }

        private string GeneratePythonReadValue(FieldType type)
        {
            return type switch
            {
                FieldType.Int32 => "reader.read_int32()",
                FieldType.Int64 => "reader.read_int64()",
                FieldType.Float => "reader.read_float()",
                FieldType.Double => "reader.read_double()",
                FieldType.Bool => "reader.read_bool()",
                FieldType.String => "reader.read_string()",
                _ => "reader.read_object()"
            };
        }
    }
}